// This file is auto-generated by @hey-api/openapi-ts

import type { OptionsLegacyParser } from '@hey-api/client-axios';
import { queryOptions, type UseMutationOptions } from '@tanstack/react-query';
import type { LoginAccessTokenData, LoginAccessTokenError, LoginAccessTokenResponse, TestTokenError, TestTokenResponse, GetARecordData, GetPtrRecordData, GetZoneMasterFromDnsServersData, GetMxRecordData, GetNsRecordsData, ReadUsersData, CreateUserData, CreateUserError, CreateUserResponse, DeleteUserMeError, DeleteUserMeResponse, UpdateUserMeData, UpdateUserMeError, UpdateUserMeResponse, UpdatePasswordMeData, UpdatePasswordMeError, UpdatePasswordMeResponse, RegisterUserData, RegisterUserError, RegisterUserResponse, ReadUserByIdData, UpdateUserData, UpdateUserError, UpdateUserResponse, DeleteUserData, DeleteUserError, DeleteUserResponse, GetUserActionsData, FindPleskSubscriptionByDomainData, GetSubscriptionLoginLinkData, GetSubscriptionLoginLinkError, GetSubscriptionLoginLinkResponse } from '../types.gen';
import type { AxiosError } from 'axios';
import { client, loginAccessToken, testToken, getARecord, getPtrRecord, getZoneMasterFromDnsServers, getMxRecord, getNsRecords, readUsers, createUser, readUserMe, deleteUserMe, updateUserMe, updatePasswordMe, registerUser, readUserById, updateUser, deleteUser, getUserActions, findPleskSubscriptionByDomain, getSubscriptionLoginLink, healthCheck } from '../sdk.gen';

type QueryKey<TOptions extends OptionsLegacyParser> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends OptionsLegacyParser>(id: string, options?: TOptions, infinite?: boolean): QueryKey<TOptions>[0] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: (options?.client ?? client).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return params;
};

export const loginAccessTokenQueryKey = (options: OptionsLegacyParser<LoginAccessTokenData>) => [
    createQueryKey('loginAccessToken', options)
];

export const loginAccessTokenOptions = (options: OptionsLegacyParser<LoginAccessTokenData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await loginAccessToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: loginAccessTokenQueryKey(options)
    });
};

export const loginAccessTokenMutation = (options?: Partial<OptionsLegacyParser<LoginAccessTokenData>>) => {
    const mutationOptions: UseMutationOptions<LoginAccessTokenResponse, AxiosError<LoginAccessTokenError>, OptionsLegacyParser<LoginAccessTokenData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await loginAccessToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const testTokenQueryKey = (options?: OptionsLegacyParser) => [
    createQueryKey('testToken', options)
];

export const testTokenOptions = (options?: OptionsLegacyParser) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await testToken({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: testTokenQueryKey(options)
    });
};

export const testTokenMutation = (options?: Partial<OptionsLegacyParser>) => {
    const mutationOptions: UseMutationOptions<TestTokenResponse, AxiosError<TestTokenError>, OptionsLegacyParser> = {
        mutationFn: async (localOptions) => {
            const { data } = await testToken({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getARecordQueryKey = (options: OptionsLegacyParser<GetARecordData>) => [
    createQueryKey('getARecord', options)
];

export const getARecordOptions = (options: OptionsLegacyParser<GetARecordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getARecord({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getARecordQueryKey(options)
    });
};

export const getPtrRecordQueryKey = (options: OptionsLegacyParser<GetPtrRecordData>) => [
    createQueryKey('getPtrRecord', options)
];

export const getPtrRecordOptions = (options: OptionsLegacyParser<GetPtrRecordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPtrRecord({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPtrRecordQueryKey(options)
    });
};

export const getZoneMasterFromDnsServersQueryKey = (options: OptionsLegacyParser<GetZoneMasterFromDnsServersData>) => [
    createQueryKey('getZoneMasterFromDnsServers', options)
];

export const getZoneMasterFromDnsServersOptions = (options: OptionsLegacyParser<GetZoneMasterFromDnsServersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getZoneMasterFromDnsServers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getZoneMasterFromDnsServersQueryKey(options)
    });
};

export const getMxRecordQueryKey = (options: OptionsLegacyParser<GetMxRecordData>) => [
    createQueryKey('getMxRecord', options)
];

export const getMxRecordOptions = (options: OptionsLegacyParser<GetMxRecordData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMxRecord({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMxRecordQueryKey(options)
    });
};

export const getNsRecordsQueryKey = (options: OptionsLegacyParser<GetNsRecordsData>) => [
    createQueryKey('getNsRecords', options)
];

export const getNsRecordsOptions = (options: OptionsLegacyParser<GetNsRecordsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNsRecords({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNsRecordsQueryKey(options)
    });
};

export const readUsersQueryKey = (options?: OptionsLegacyParser<ReadUsersData>) => [
    createQueryKey('readUsers', options)
];

export const readUsersOptions = (options?: OptionsLegacyParser<ReadUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUsersQueryKey(options)
    });
};

export const createUserQueryKey = (options: OptionsLegacyParser<CreateUserData>) => [
    createQueryKey('createUser', options)
];

export const createUserOptions = (options: OptionsLegacyParser<CreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createUserQueryKey(options)
    });
};

export const createUserMutation = (options?: Partial<OptionsLegacyParser<CreateUserData>>) => {
    const mutationOptions: UseMutationOptions<CreateUserResponse, AxiosError<CreateUserError>, OptionsLegacyParser<CreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUserMeQueryKey = (options?: OptionsLegacyParser) => [
    createQueryKey('readUserMe', options)
];

export const readUserMeOptions = (options?: OptionsLegacyParser) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUserMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUserMeQueryKey(options)
    });
};

export const deleteUserMeMutation = (options?: Partial<OptionsLegacyParser>) => {
    const mutationOptions: UseMutationOptions<DeleteUserMeResponse, AxiosError<DeleteUserMeError>, OptionsLegacyParser> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateUserMeMutation = (options?: Partial<OptionsLegacyParser<UpdateUserMeData>>) => {
    const mutationOptions: UseMutationOptions<UpdateUserMeResponse, AxiosError<UpdateUserMeError>, OptionsLegacyParser<UpdateUserMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updatePasswordMeMutation = (options?: Partial<OptionsLegacyParser<UpdatePasswordMeData>>) => {
    const mutationOptions: UseMutationOptions<UpdatePasswordMeResponse, AxiosError<UpdatePasswordMeError>, OptionsLegacyParser<UpdatePasswordMeData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePasswordMe({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const registerUserQueryKey = (options: OptionsLegacyParser<RegisterUserData>) => [
    createQueryKey('registerUser', options)
];

export const registerUserOptions = (options: OptionsLegacyParser<RegisterUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await registerUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: registerUserQueryKey(options)
    });
};

export const registerUserMutation = (options?: Partial<OptionsLegacyParser<RegisterUserData>>) => {
    const mutationOptions: UseMutationOptions<RegisterUserResponse, AxiosError<RegisterUserError>, OptionsLegacyParser<RegisterUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await registerUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const readUserByIdQueryKey = (options: OptionsLegacyParser<ReadUserByIdData>) => [
    createQueryKey('readUserById', options)
];

export const readUserByIdOptions = (options: OptionsLegacyParser<ReadUserByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await readUserById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: readUserByIdQueryKey(options)
    });
};

export const updateUserMutation = (options?: Partial<OptionsLegacyParser<UpdateUserData>>) => {
    const mutationOptions: UseMutationOptions<UpdateUserResponse, AxiosError<UpdateUserError>, OptionsLegacyParser<UpdateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteUserMutation = (options?: Partial<OptionsLegacyParser<DeleteUserData>>) => {
    const mutationOptions: UseMutationOptions<DeleteUserResponse, AxiosError<DeleteUserError>, OptionsLegacyParser<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserActionsQueryKey = (options: OptionsLegacyParser<GetUserActionsData>) => [
    createQueryKey('getUserActions', options)
];

export const getUserActionsOptions = (options: OptionsLegacyParser<GetUserActionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserActions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserActionsQueryKey(options)
    });
};

export const findPleskSubscriptionByDomainQueryKey = (options: OptionsLegacyParser<FindPleskSubscriptionByDomainData>) => [
    createQueryKey('findPleskSubscriptionByDomain', options)
];

export const findPleskSubscriptionByDomainOptions = (options: OptionsLegacyParser<FindPleskSubscriptionByDomainData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await findPleskSubscriptionByDomain({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: findPleskSubscriptionByDomainQueryKey(options)
    });
};

export const getSubscriptionLoginLinkQueryKey = (options: OptionsLegacyParser<GetSubscriptionLoginLinkData>) => [
    createQueryKey('getSubscriptionLoginLink', options)
];

export const getSubscriptionLoginLinkOptions = (options: OptionsLegacyParser<GetSubscriptionLoginLinkData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSubscriptionLoginLink({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSubscriptionLoginLinkQueryKey(options)
    });
};

export const getSubscriptionLoginLinkMutation = (options?: Partial<OptionsLegacyParser<GetSubscriptionLoginLinkData>>) => {
    const mutationOptions: UseMutationOptions<GetSubscriptionLoginLinkResponse, AxiosError<GetSubscriptionLoginLinkError>, OptionsLegacyParser<GetSubscriptionLoginLinkData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await getSubscriptionLoginLink({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const healthCheckQueryKey = (options?: OptionsLegacyParser) => [
    createQueryKey('healthCheck', options)
];

export const healthCheckOptions = (options?: OptionsLegacyParser) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await healthCheck({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: healthCheckQueryKey(options)
    });
};